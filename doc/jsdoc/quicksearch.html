<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"child_service_index.js.html":{"id":"child_service_index.js.html","title":"Source: child_service/index.js","body":" cukelib Modules childServicerequestSupportserviceControlshellSupportutilities Source: child_service/index.js /* eslint max-len: [&quot;error&quot;, { &quot;code&quot;: 100, &quot;ignoreComments&quot;: true }]*/ /** * @module childService */ // @flow const _ = require('lodash'); const Promise = require('bluebird'); const childProcess = require('child_process'); const chalk = require('chalk'); const serviceControl = require('../service_control'); const universe = require('../universe'); const { get, unset } = universe.namespaceFactory('_cukelib'); const killProcWhenOrphaned = function (proc, name) { const removeListenerList = 'exit SIGHUP SIGINT SIGQUIT SIGILL SIGABRT SIGFPE SIGSEGV SIGPIPE SIGTERM SIGBUS' .split(/\\s+/) .map((sig) =&gt; { const killFn = () =&gt; { unset(`_services.${name}`); proc.kill('SIGTERM'); }; process.on(sig, killFn); return () =&gt; process.removeListener(sig, killFn); }); return () =&gt; removeListenerList.map((rmListener) =&gt; rmListener()); }; const promiseToResolveOnMatch = (stream, matchTarget) =&gt; new Promise((resolve) =&gt; { const resolveOnMatch = (data) =&gt; { if (data.toString().match(matchTarget)) { resolve(data); stream.removeListener('data', resolveOnMatch); } }; stream.on('data', resolveOnMatch); }); const childService = module.exports = { /** * initialize - Initializes the childService using the serviceControl module * * Typically called at the top of cucumber support file that uses the childService using the * cucumber context that contains `Before`, `After`, `Given`, etc. * Usage: * * - `childService.initialize.call(this); ` * * @returns {undefined} */ initialize() { return serviceControl.initialize.call(this); }, /** * getService - Given a childService name returns the childService object. * * @param {string} name * * @returns {Object} childService */ getService(name: string) { return serviceControl.getService(`child.${name}`); }, makeSpawnConfig(spawnArgs: Object) { if (!spawnArgs.name) throw new Error('name is a required argument'); const spawnDefaultArgs = { args: [], options: {}, isReadyMatch: /./, isReady(proc) { return Promise.race([ promiseToResolveOnMatch(proc.stdout, spawnArgs.isReadyMatch), promiseToResolveOnMatch(proc.stderr, spawnArgs.isReadyMatch), ]); }, stderrHandler(data) { // eslint-disable-next-line no-console console.error(chalk.magenta(`${spawnArgs.name}.stderr: ${data}`)); }, stdoutHandler(data) { // eslint-disable-next-line no-console console.log(chalk.magenta(`${spawnArgs.name}.stdout: ${data}`)); }, errorHandler(err) { // eslint-disable-next-line no-console console.log(chalk.magenta(`${spawnArgs.name} Error:`, err)); } }; return _.defaults(spawnArgs, spawnDefaultArgs); }, launch(configOverrides: Object = {}, childLauncher: Function) { const config = childService.makeSpawnConfig(configOverrides); const start = () =&gt; { let isProcReady = false; return childLauncher(config) .then((proc) =&gt; { proc.stderr.on('data', config.stderrHandler); proc.stdout.on('data', config.stdoutHandler); proc.on('error', config.errorHandler); const exitPromise = new Promise((resolve, reject) =&gt; { proc.once('exit', (code) =&gt; { if (isProcReady) { // This is the resolution case for the stop function. const msg = `Server &quot;${config.name}&quot; exited with code ${code}`; if (get(`_services.${config.name}`)) { // This happens if the proc exits from something other than the stop. reject(new Error(msg)); } else { // This is the normal exit case from the stop. resolve(msg); } } else { // This is the resolution case for the Promise.race against isReadyPromise reject(new Error(`Server &quot;${config.name}&quot; exited with code ${code} before ready`)); } }); }); const removeOrphanProcListeners = killProcWhenOrphaned(proc, config.name); const isReadyPromise = config.isReady.call(config, proc) .then(() =&gt; { isProcReady = true; return { config, proc, stop: () =&gt; { removeOrphanProcListeners(); proc.kill('SIGTERM'); return exitPromise; }, }; }); return Promise.race([isReadyPromise, exitPromise]); }); }; return serviceControl.launchService(config.name, start); }, /** * spawn - Launches a Node child process from a shell command via * * [`require('child_process').spawn(...)`](https://nodejs.org/api/child_process.html#child_process_child_process_spawn_command_args_options) * * The `spawnArgs` parameter allows these options: * * - `name: string` The name of the cukelib service (required). * - `cmd: string` Spawn command argument (required). * - `args: [string]` Spawn args argument * - `options: Object` [childProcess.spawn options argument (env, cwd, etc.)](https://nodejs.org/api/child_process.html#child_process_child_process_spawn_command_args_options) * - `isReadyMatch: string|RegExp` default: `/./` Pattern that is matched from stdout or stderr to indicate the child process is ready. * - `isReady: (proc: childProcess) =&gt; Promise` the promise is resolved when the child process is ready. The default is to resolve when data from stdout or stderr matches the `isReadyMatch` pattern. * - `stderrHandler: Function(data: string)` default is to print via `console.error(chalk.magenta(...))` * - `stdoutHandler: Function(data: string)` default is to print via `console.log(chalk.magenta(...))`. Assign the function `(data) =&gt; null` for a &quot;quiet&quot; output. * - `errorHandler: Function(err: Error)` default is to print the err via `console.error(chalk.magenta(...))` * * @param {Object} [spawnArgs={}] see above * * @returns {Promise} launchService promise */ spawn(spawnArgs: Object = {}) { if (!spawnArgs.cmd) throw new Error('cmd is a required argument'); return childService.launch(spawnArgs, (config) =&gt; Promise.resolve(childProcess.spawn(config.cmd, config.args, config.options))); }, }; module.exports = childService; × Search results Close Documentation generated by JSDoc 3.4.3 on Mon Feb 20th 2017 using the DocStrap template. "},"request_support.js.html":{"id":"request_support.js.html","title":"Source: request_support.js","body":" cukelib Modules childServicerequestSupportserviceControlshellSupportutilities Source: request_support.js /** * requestSupport * @module requestSupport */ // @flow const _ = require('lodash'); const yaml = require('js-yaml'); const handlebars = require('handlebars'); const requestPromise = require('request-promise'); const { parseStepArg } = require('./utilities'); const { get, set, unset, log, log3, initializeWith } = require('./universe').namespaceFactory('_cukelib'); const requestCommon = (routeStr, options) =&gt; { // combine options const requestOptions = _.defaults({}, options, get('_request.defaultOptions')); // construct URL const url = handlebars.compile(`${requestOptions.host}/${routeStr.replace(/^\\//, '')}`)(get()); requestOptions.url = url; delete requestOptions.host; // get cookie jar if (requestOptions.jar) { requestOptions.jar = get('_requestCookieJar') || set('_requestCookieJar', requestPromise.jar()); } // send request, log everything, capture response set('_requestOptions', requestOptions); log3('log3', 'requestOptions', requestOptions); const responsePromise = requestPromise(requestOptions); set('_requestResponsePromise', responsePromise); return responsePromise.then((result) =&gt; { log('response headers', result.headers); log('response body', result.body); unset('_requestResponsePromise'); set('_requestResponse', result); return responsePromise; }) .catch((err) =&gt; { log('err', err); return responsePromise; }); }; const parseYamlBody = (bodyStr) =&gt; { if (_.isPlainObject(bodyStr)) return bodyStr; if (!_.isString(bodyStr)) { throw new Error(`expected a string, but got ${bodyStr}`); } try { return yaml.safeLoad(bodyStr); } catch (err) { err.message += ' Error parsing:\\n' + bodyStr; // eslint-disable-line prefer-template throw err; } }; module.exports = { /** * Initializes the &quot;request&quot; defaults. Should be called in a context which * contains the CucumberJS methods (`Given`, `Then`, `Before`, etc.) * * @example * requestSupport.initialize.call(this, options); * * @param {object} [options={}] merged with * Merged with [standard defaults](request_support.js.html#sunlight-1-line-67) * to set request defaultOptions * * @returns undefined */ initialize(options: Object = {}) { initializeWith.call(this, { _request: { defaultOptions: _.defaults({}, options, { host: 'http://localhost:3000', method: 'GET', simple: false, body: {}, resolveWithFullResponse: true, json: true, jar: true, }), }, }); }, /** * requestGET - Description * * @param {string} routeStr Description * @param {object} [options={}] Description * * @returns {type} Description */ requestGET(routeStr: string, options: Object = {}) { return requestCommon( routeStr, _.assign({ method: 'GET' }, options) ); }, requestPUT(routeStr: string, bodyStr: string|Object, options: Object = {}) { const done = (typeof bodyStr === 'function') ? bodyStr : null; const responsePromise = requestCommon( routeStr, _.assign({ method: 'PUT', body: done ? {} : parseYamlBody(parseStepArg(bodyStr)) }, options) ); if (done) { responsePromise.asCallback(done); return null; } return responsePromise; }, requestDELETE(routeStr: string, options: Object = {}) { return requestCommon( routeStr, _.assign({ method: 'DELETE' }, options) ); }, /** * Executes POST request to given `routeStr` * * `bodyStr` * - as a string will be interpreted as JSON and passed to the request. * - as an object with a `raw` property it is interpreted as a single tow cucumber table. * The table contents are merged, interpreted as JSON and passed to the request. * - as a plainObject it is passsed directly to the request. * - as a function it is assumed to be a `done` callback and an empty body is sent to the request * * @param {string} routeStr * @param {string|object|function} bodyStr * @param {object} [options={}] Overides to the request defaults. * * @returns {Promise|null} Response promise from `request` or `null` for callback style calls. */ requestPOST(routeStr: string, bodyStr: string|Object, options: Object = {}) { const done = (typeof bodyStr === 'function') ? bodyStr : null; const responsePromise = requestCommon( routeStr, _.assign({ method: 'POST', body: done ? {} : parseYamlBody(parseStepArg(bodyStr)) }, options) ); if (done) { responsePromise.asCallback(done); return null; } return responsePromise; }, }; × Search results Close Documentation generated by JSDoc 3.4.3 on Mon Feb 20th 2017 using the DocStrap template. "},"service_control_index.js.html":{"id":"service_control_index.js.html","title":"Source: service_control/index.js","body":" cukelib Modules childServicerequestSupportserviceControlshellSupportutilities Source: service_control/index.js /** * @module serviceControl */ // @flow const _ = require('lodash'); const Promise = require('bluebird'); const universe = require('../universe'); const serviceControlNS = universe.namespaceFactory('_cukelib'); const { get, set, log3, unset, hasKey, getCukeContext, initializeWith } = serviceControlNS; const listServices = (serviceRoot: string, depth: number) =&gt; { let serviceList = []; _.forIn(get(serviceRoot ? `_services.${serviceRoot}` : '_services'), (candidate, name) =&gt; { const namePath = serviceRoot ? `${serviceRoot}.${name}` : name; if (candidate.cukeContext) { serviceList.push(namePath); } else if (depth &lt; 10) { const deepServiceList = listServices(namePath, depth + 1); serviceList = serviceList.concat(deepServiceList); } }); return serviceList; }; const serviceControl = module.exports = { serviceControlNS, addBoilerPlate(prefix: string, serviceObject: Object) { return _.defaults(serviceObject, { initialize() { return serviceControl.initialize.call(this); }, getService(name) { return serviceControl.getService(`${prefix}.${name}`); }, }); }, initialize() { if (hasKey('_services')) return; initializeWith.call(this, { _services: {} }); const cukeContextKiller = (cukeContext) =&gt; { const killTheseServices = listServices('', 0) .filter((namePath) =&gt; get(`_services.${namePath}`).cukeContext === cukeContext); log3('log3', 'killTheseServices', killTheseServices); return Promise.map(killTheseServices, (name) =&gt; serviceControl.stopService(name)); }; this.After(cukeContextKiller.bind(null, 'scenario')); this.registerHandler('AfterFeature', cukeContextKiller.bind(null, 'feature')); this.registerHandler('AfterFeatures', cukeContextKiller.bind(null, 'universe')); }, stopService(name: string) { log3('log3', 'serviceControl/stopService', name); const service = get(`_services.${name}`); if (!service) return Promise.resolve(`no service for ${name}`); unset(`_services.${name}`); if (service.stop) { return service.stop(); } else if ((service.proc || {}).kill) { service.removeListeners(); service.proc.kill('SIGTERM'); return service.exitPromise; } throw new Error(`Don't know how to stop service &quot;${name}&quot;`); }, /** * @param {string} name service name * * @returns {Object} universe service object root */ getService(name: string) { return get(`_services.${name}`); }, launchService(name: string, start: () =&gt; Object) { log3('log3', 'serviceControl/launchService', name); if (!get('_services')) { throw new Error('tried to launchService before service_control was initialized'); } return serviceControl.stopService(name) .then(start) .then((service) =&gt; { if (!service.stop || !_.isFunction(service.stop)) { throw new Error(`service '${name}' is missing a stop function`); } set(`_services.${name}`, service); service.name = name; // eslint-disable-line no-param-reassign service.cukeContext = getCukeContext(); // eslint-disable-line no-param-reassign return service; }); }, }; × Search results Close Documentation generated by JSDoc 3.4.3 on Mon Feb 20th 2017 using the DocStrap template. "},"shell_support.js.html":{"id":"shell_support.js.html","title":"Source: shell_support.js","body":" cukelib Modules childServicerequestSupportserviceControlshellSupportutilities Source: shell_support.js /** * @module shellSupport */ // @flow const _ = require('lodash'); const expect = require('chai').expect; const childProcess = require('child_process'); const { parseStepArg } = require('./utilities'); const { get, set, initializeWith } = require('./universe').namespaceFactory('_cukelib'); type Stream = 'STDOUT' | 'STDERR'; const shellSupport = module.exports = { initialize() { return initializeWith.call(this); }, /** * Runs `scriptStr` lines in a childProcess * * Results of the run are stored in the universe at * `_shellSTDOUT`, `_shellSTDERR`, and `_shellError`. * In particular the status code of execution is in `_shellError.code` * * Note that the `STDOUT` ans `STDERR` result accumulate over multiple steps. * Use {@link module:shell_support.resetShell|resetShell} to clear the previous results. * * @param {string} scriptStr shell script * @param {function} done childProcess completed callback * * @returns undefined */ runShell(scriptStr: string|Object, done: Function) { const script = parseStepArg(scriptStr); childProcess.exec(script, (error, stdout, stderr) =&gt; { set('_shellSTDOUT', (get('_shellSTDOUT') || '') + stdout); set('_shellSTDERR', (get('_shellSTDERR') || '') + stderr); set('_shellError', error); done(error); }); }, /** * Same as {@link module:shell_support.runShell|runShell}, * but doesn't fail when the execution errors. */ runSkipError(scriptStr: string|Object, done: Function) { shellSupport.runShell.call(this, scriptStr, () =&gt; done()); }, /** resets (clears) the shell STDERR and STDOUT universe variable. * (Shell output is cumulative over multiple steps.) */ resetShell() { set('_shellSTDOUT', ''); set('_shellSTDERR', ''); set('_shellError', null); }, inspectShellOutput() { /* eslint-disable no-console */ console.log('STDOUT:'); console.log(get('_shellSTDOUT')); console.log('STDERR:'); console.log(get('_shellSTDERR')); const shellErr = get('_shellError'); if (shellErr) { console.log('Shell Error:'); console.log(shellErr); } /* eslint-enable no-console */ }, resultEqual(stream: Stream, data: string|Object) { expect(get(`_shell${stream}`).trim()).to.equal(parseStepArg(data)); }, resultErrorCode(targetCode: string) { expect(get('_shellError.code')).to.equal(_.toNumber(targetCode)); }, resultRegexMatch(stream: Stream, data: string|Object) { const re = new RegExp(data); expect(get(`_shell${stream}`).trim()).to.match(re); }, resultTemplateMatch(stream: Stream, targetTemplate: string|Object) { const target = parseStepArg(targetTemplate); expect(get(`_shell${stream}`).trim()).to.equal(target); }, }; × Search results Close Documentation generated by JSDoc 3.4.3 on Mon Feb 20th 2017 using the DocStrap template. "},"utilities_index.js.html":{"id":"utilities_index.js.html","title":"Source: utilities/index.js","body":" cukelib Modules childServicerequestSupportserviceControlshellSupportutilities Source: utilities/index.js /** * @module utilities */ const _ = require('lodash'); const handlebars = require('handlebars'); const { get } = require('../universe').namespaceFactory('_cukelib'); module.exports = { /** * Parses a step argument so that it treats a single cell cucumber table as plain text, * and then evaluates it as a handlebars template using the cucumber _cukelib namespace object. * * @param {string|Object} stepArg * * @returns {string} */ parseStepArg(stepArg) { let toCompile = stepArg; if (stepArg.raw) { const dataTable = stepArg.raw(); if (dataTable.length === 1) { toCompile = dataTable[0].join('|'); } else { throw new Error(&quot;This doesn't look like a single cell table.&quot;); } } return _.isString(toCompile) ? handlebars.compile(toCompile.trim())(get()) : stepArg; }, }; × Search results Close Documentation generated by JSDoc 3.4.3 on Mon Feb 20th 2017 using the DocStrap template. "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" cukelib Modules childServicerequestSupportserviceControlshellSupportutilities Modules × Search results Close Documentation generated by JSDoc 3.4.3 on Mon Feb 20th 2017 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" cukelib Modules childServicerequestSupportserviceControlshellSupportutilities cukelib module documentationback to github × Search results Close Documentation generated by JSDoc 3.4.3 on Mon Feb 20th 2017 using the DocStrap template. "},"module-childService.html":{"id":"module-childService.html","title":"Module: childService","body":" cukelib Modules childServicerequestSupportserviceControlshellSupportutilities Module: childService Source: child_service/index.js, line 2 Methods &lt;static&gt; getService(name) getService - Given a childService name returns the childService object. Parameters: Name Type Description name string Source: child_service/index.js, line 60 Returns: childService Type Object &lt;static&gt; initialize() initialize - Initializes the childService using the serviceControl module Typically called at the top of cucumber support file that uses the childService using thecucumber context that contains Before, After, Given, etc.Usage: childService.initialize.call(this); Source: child_service/index.js, line 49 Returns: Type undefined &lt;static&gt; spawn( [spawnArgs]) spawn - Launches a Node child process from a shell command via require('child_process').spawn(...) The spawnArgs parameter allows these options: name: string The name of the cukelib service (required). cmd: string Spawn command argument (required). args: [string] Spawn args argument options: Object childProcess.spawn options argument (env, cwd, etc.) isReadyMatch: string|RegExp default: /./ Pattern that is matched from stdout or stderr to indicate the child process is ready. isReady: (proc: childProcess) =&gt; Promise the promise is resolved when the child process is ready. The default is to resolve when data from stdout or stderr matches the isReadyMatch pattern. stderrHandler: Function(data: string) default is to print via console.error(chalk.magenta(...)) stdoutHandler: Function(data: string) default is to print via console.log(chalk.magenta(...)). Assign the function (data) =&gt; null for a &quot;quiet&quot; output. errorHandler: Function(err: Error) default is to print the err via console.error(chalk.magenta(...)) Parameters: Name Type Argument Default Description spawnArgs Object &lt;optional&gt; {} see above Source: child_service/index.js, line 155 Returns: launchService promise Type Promise × Search results Close Documentation generated by JSDoc 3.4.3 on Mon Feb 20th 2017 using the DocStrap template. "},"module-requestSupport.html":{"id":"module-requestSupport.html","title":"Module: requestSupport","body":" cukelib Modules childServicerequestSupportserviceControlshellSupportutilities Module: requestSupport requestSupport Source: request_support.js, line 1 Methods &lt;static&gt; initialize( [options]) Initializes the &quot;request&quot; defaults. Should be called in a context whichcontains the CucumberJS methods (Given, Then, Before, etc.) Parameters: Name Type Argument Default Description options object &lt;optional&gt; {} merged with Merged with standard defaults to set request defaultOptions Source: request_support.js, line 69 Returns: undefined Example requestSupport.initialize.call(this, options); &lt;static&gt; requestGET(routeStr [, options]) requestGET - Description Parameters: Name Type Argument Default Description routeStr string Description options object &lt;optional&gt; {} Description Source: request_support.js, line 93 Returns: Description Type type &lt;static&gt; requestPOST(routeStr, bodyStr [, options]) Executes POST request to given routeStr bodyStr as a string will be interpreted as JSON and passed to the request. as an object with a raw property it is interpreted as a single tow cucumber table.The table contents are merged, interpreted as JSON and passed to the request. as a plainObject it is passsed directly to the request. as a function it is assumed to be a done callback and an empty body is sent to the request Parameters: Name Type Argument Default Description routeStr string bodyStr string | object | function options object &lt;optional&gt; {} Overides to the request defaults. Source: request_support.js, line 127 Returns: Response promise from request or null for callback style calls. Type Promise | null × Search results Close Documentation generated by JSDoc 3.4.3 on Mon Feb 20th 2017 using the DocStrap template. "},"module-serviceControl.html":{"id":"module-serviceControl.html","title":"Module: serviceControl","body":" cukelib Modules childServicerequestSupportserviceControlshellSupportutilities Module: serviceControl Source: service_control/index.js, line 1 Methods &lt;static&gt; getService(name) Parameters: Name Type Description name string service name Source: service_control/index.js, line 74 Returns: universe service object root Type Object × Search results Close Documentation generated by JSDoc 3.4.3 on Mon Feb 20th 2017 using the DocStrap template. "},"module-shellSupport.html":{"id":"module-shellSupport.html","title":"Module: shellSupport","body":" cukelib Modules childServicerequestSupportserviceControlshellSupportutilities Module: shellSupport Source: shell_support.js, line 1 Methods &lt;static&gt; resetShell() resets (clears) the shell STDERR and STDOUT universe variable.(Shell output is cumulative over multiple steps.) Source: shell_support.js, line 52 &lt;static&gt; runShell(scriptStr, done) Runs scriptStr lines in a childProcess Results of the run are stored in the universe at_shellSTDOUT, _shellSTDERR, and _shellError.In particular the status code of execution is in _shellError.code Note that the STDOUT ans STDERR result accumulate over multiple steps.Use resetShell to clear the previous results. Parameters: Name Type Description scriptStr string shell script done function childProcess completed callback Source: shell_support.js, line 31 Returns: undefined &lt;static&gt; runSkipError() Same as runShell,but doesn't fail when the execution errors. Source: shell_support.js, line 45 × Search results Close Documentation generated by JSDoc 3.4.3 on Mon Feb 20th 2017 using the DocStrap template. "},"module-utilities.html":{"id":"module-utilities.html","title":"Module: utilities","body":" cukelib Modules childServicerequestSupportserviceControlshellSupportutilities Module: utilities Source: utilities/index.js, line 1 Methods &lt;static&gt; parseStepArg(stepArg) Parses a step argument so that it treats a single cell cucumber table as plain text,and then evaluates it as a handlebars template using the cucumber _cukelib namespace object. Parameters: Name Type Description stepArg string | Object Source: utilities/index.js, line 17 Returns: Type string × Search results Close Documentation generated by JSDoc 3.4.3 on Mon Feb 20th 2017 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
